"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1318],{58034:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorial/development/environments/spatialhashenv","title":"SpatialHashEnvironment (Grid Environment)","description":"A grid is an environment in which the world is divided into cells of equal size, like on a chessboard. An object (an agent or an entity) on the grid can be moved along the horizontal, vertical, and diagonal axes. A simple example showing a few functionalities can be found here.","source":"@site/docs/tutorial/development/environments/spatialhashenv.md","sourceDirName":"tutorial/development/environments","slug":"/tutorial/development/environments/spatialhashenv","permalink":"/docs/tutorial/development/environments/spatialhashenv","draft":false,"unlisted":false,"editUrl":"https://github.com/MARS-Group-HAW/MARS-Group-HAW.github.io/edit/main/docs/tutorial/development/environments/spatialhashenv.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Environments","permalink":"/docs/tutorial/development/environments/"},"next":{"title":"GeoHashEnvironment (Geospatial Grid Environment)","permalink":"/docs/tutorial/development/environments/geohashenv"}}');var o=i(74848),r=i(28453);const a={sidebar_position:1},s="SpatialHashEnvironment (Grid Environment)",d={},l=[{value:"Creating an environment",id:"creating-an-environment",level:2},{value:"Interaction with/within the Grid Environment",id:"interaction-withwithin-the-grid-environment",level:2},{value:"Add an agent to the environment",id:"add-an-agent-to-the-environment",level:3},{value:"Remove an existing object",id:"remove-an-existing-object",level:3},{value:"Move an agent to another location",id:"move-an-agent-to-another-location",level:3},{value:"Explore other agents and resources",id:"explore-other-agents-and-resources",level:2},{value:"Importing data for a Grid Environment",id:"importing-data-for-a-grid-environment",level:2},{value:"Exporting data for a Grid Environment",id:"exporting-data-for-a-grid-environment",level:2},{value:"Special Cases",id:"special-cases",level:2},{value:"How to Calculate a Bearing",id:"how-to-calculate-a-bearing",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"spatialhashenvironment-grid-environment",children:"SpatialHashEnvironment (Grid Environment)"})}),"\n",(0,o.jsxs)(n.p,{children:["A grid is an environment in which the world is divided into cells of equal size, like on a chessboard. An object (an agent or an entity) on the grid can be moved along the horizontal, vertical, and diagonal axes. A simple example showing a few functionalities can be found ",(0,o.jsx)(n.a,{href:"https://git.haw-hamburg.de/mars/model-deployments/-/tree/master/C%23%20Models/Grid_Test%20CS",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-an-environment",children:"Creating an environment"}),"\n",(0,o.jsxs)(n.p,{children:["In MARS, a grid environment is represented as a ",(0,o.jsx)(n.code,{children:"SpatialHashEnvironment"})," with two dimensions, corresponding to the x-axis and y-axis of a Cartesian coordinate system. To initialize a grid environment, the size of each dimension needs to be specified."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"IEnvironment<Sheep> Environment = new SpatialHashEnvironment<Sheep>(10, 10);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the initialized ",(0,o.jsx)(n.code,{children:"Environment"})," consists of 10 x 10 individual cells. The grid is defined by a so-called bounding box with lower-left bound (0,0) and upper-right bound (9,9). The ",(0,o.jsx)(n.code,{children:"Sheep"})," agents live on the ",(0,o.jsx)(n.code,{children:"Environment"})," can be defined to move on it as described below."]}),"\n",(0,o.jsxs)(n.p,{children:["Optionally, a ",(0,o.jsx)(n.code,{children:"cellSize"})," can be specified to change the size of an individual grid cell (default is 1)."]}),"\n",(0,o.jsx)(n.h2,{id:"interaction-withwithin-the-grid-environment",children:"Interaction with/within the Grid Environment"}),"\n",(0,o.jsx)(n.h3,{id:"add-an-agent-to-the-environment",children:"Add an agent to the environment"}),"\n",(0,o.jsxs)(n.p,{children:["To add an object (for example, an agent or entity) to the grid, the ",(0,o.jsx)(n.code,{children:"Insert()"})," method of the ",(0,o.jsx)(n.code,{children:"environment"})," is used."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Position = RandomPosition();\nEnvironment.Insert(this);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This example takes place in the initialization method of an agent ",(0,o.jsx)(n.code,{children:"Sheep"}),". The agent has a property ",(0,o.jsx)(n.code,{children:"Position"}),". This property is initialized with a random position that consists of a tuple (x,y). Once the agent has a defined position, it can be placed on the ",(0,o.jsx)(n.code,{children:"Environment"})," by calling the environment's ",(0,o.jsx)(n.code,{children:"Insert(<object reference>)"})," method and passing a reference to the agent."]}),"\n",(0,o.jsx)(n.h3,{id:"remove-an-existing-object",children:"Remove an existing object"}),"\n",(0,o.jsxs)(n.p,{children:["Removing an agent follows the same principle as adding it. The ",(0,o.jsx)(n.code,{children:"Remove(<object to remove>)"})," method is executed via the ",(0,o.jsx)(n.code,{children:"Environment"})," and the entity to be removed is specified."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Environment.Remove(<object to remove>);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"move-an-agent-to-another-location",children:"Move an agent to another location"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"SpatialHashEnvironment"})," (i.e., the grid environment) enables agents to move on it. There are three movement methods, which are illustrated in the following examples."]}),"\n",(0,o.jsxs)(n.p,{children:["The first movement method is ",(0,o.jsx)(n.code,{children:"MoveTo()"}),", which is called as shown below."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Environment.MoveTo(this, <position tuple (x, y)>);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Upon execution of the above code, the ",(0,o.jsx)(n.code,{children:"Environment"})," determines the shortest path between the agent's current position and the goal position specified in the method's second parameter."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," There are different options for the second parameter of ",(0,o.jsx)(n.code,{children:"MoveTo()"}),". Alternatively to the tuple shown above, the method can take two individual double values \u2013 representing the x- and y-coordinate of the desired position, respectively \u2013 as the second and third parameter. Or an array of double values can be passed to represent a path which the agent should travel along."]}),"\n",(0,o.jsxs)(n.p,{children:["The second movement method is ",(0,o.jsx)(n.code,{children:"MoveTowards()"}),". This method can be called either with a ",(0,o.jsx)(n.code,{children:"DirectionType"})," enum or with a bearing double."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Environment.MoveTowards(this, <DirectionType>);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Environment.MoveTowards(this, <bearing>);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"DirectionType"})," enum can be ",(0,o.jsx)(n.code,{children:"Up"}),", ",(0,o.jsx)(n.code,{children:"Down"}),", ",(0,o.jsx)(n.code,{children:"UpRight"}),", ",(0,o.jsx)(n.code,{children:"UpLeft"}),", etc. The bearing can be a double between 0.0 (equivalent to the direction type ",(0,o.jsx)(n.code,{children:"Up"}),") and 360.0 and specifies the angle to which the agent should turn and move. For more information on how to calculate a bearing, please see ",(0,o.jsx)(n.a,{href:"#how-to-calculate-a-bearing",children:"here"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," The ",(0,o.jsx)(n.code,{children:"SpatialHashEnvironment"})," provides the following properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"CheckBoundaries"}),": Checking for specified boundaries and reposition entities that move out the dimensions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"DistanceFunction"}),": The distance function used for ",(0,o.jsx)(n.code,{children:"Explore"})," and ",(0,o.jsx)(n.code,{children:"Move"})," actions, interpreting the passed exploration radius or moving distance (default is ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Chebyshev_distance",children:"Chebyshev"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"explore-other-agents-and-resources",children:"Explore other agents and resources"}),"\n",(0,o.jsxs)(n.p,{children:["Agents can explore an environment to identify other agents and resources by calling the ",(0,o.jsx)(n.code,{children:"Explore()"})," method on the environment. Below is an example."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"IEnumerable<Sheep> result = Environment.Explore();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This call explores the ",(0,o.jsx)(n.code,{children:"Environment"})," for ",(0,o.jsx)(n.code,{children:"Sheep"})," agents. Since no parameters are specified, the entire ",(0,o.jsx)(n.code,{children:"Environment"})," is explored. ",(0,o.jsx)(n.strong,{children:"Note: in simulations with many agents, this can be computationally costly."})]}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, the ",(0,o.jsx)(n.code,{children:"Explore()"})," method can also be called with parameters. The signature is ",(0,o.jsx)(n.code,{children:"Explore(<position>, <search_radius>, <number_of_objects>, <filter_predicate>)"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"position"})," is the position (consisting of an ",(0,o.jsx)(n.code,{children:"x"})," and ",(0,o.jsx)(n.code,{children:"y"})," coordinate) from which the exploration should begin (e.g., the caller's current position)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"<search_radius>"})," is the extent of the exploration (e.g., an ",(0,o.jsx)(n.code,{children:"Explore()"})," call with a search radius of ",(0,o.jsx)(n.code,{children:"5"})," on a grid environment explores the environment within five grid cells of the specified ",(0,o.jsx)(n.code,{children:"<position>"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"<number_of_objects>"})," is the maximum number of objects (i.e., ",(0,o.jsx)(n.code,{children:"Sheep"})," agents, in case of the current example) that should be returned as a result of the exploration."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"<filter_predicate>"})," is an optional predicate (selection expression) that can be applied to the exploration goal (in this case ",(0,o.jsx)(n.code,{children:"Sheep"})," agents) in case only those agents that satisfy a certain condition are required. Below is an example of a full ",(0,o.jsx)(n.code,{children:"Explore()"})," call."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"IEnumerable<Sheep> result = Environment.Explore(Position, 20, -1, agentInEnvironment => agentInEnvironment.Energy > 50);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, all ",(0,o.jsx)(n.code,{children:"Sheep"})," agents within ",(0,o.jsx)(n.code,{children:"20"})," steps that satisfy the ",(0,o.jsx)(n.code,{children:"Energy > 50"})," condition are returned and stored in the ",(0,o.jsx)(n.code,{children:"IEnumerable"})," collection. By specifying ",(0,o.jsx)(n.code,{children:"-1"})," in the second parameter, the results are not limited by search radius."]}),"\n",(0,o.jsxs)(n.p,{children:["Furthermore, if you want to query the entire spatial space, you specify ",(0,o.jsx)(n.code,{children:"-1D"})," for the ",(0,o.jsx)(n.code,{children:"<radius>"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"IEnumerable<Sheep> result = Environment.Explore(Position, -1D, -1, agentInEnvironment => agentInEnvironment.Energy > 50);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this case, all registered ",(0,o.jsx)(n.code,{children:"Sheep"})," agents in the environment are queried for the condition ",(0,o.jsx)(n.code,{children:"Energy > 50"}),". However, the filter specified in the fourth parameter is still applied to potentially filter the results based on whether the agents satisfy the condition ",(0,o.jsx)(n.code,{children:"Energy > 50"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," Alternatively, a ",(0,o.jsx)(n.code,{children:"Select()"})," and other LINQ queries can be formulated on the ",(0,o.jsx)(n.code,{children:"IEnumerable<Sheep> result"}),", which will be evaluated after the query is executed."]}),"\n",(0,o.jsx)(n.h2,{id:"importing-data-for-a-grid-environment",children:"Importing data for a Grid Environment"}),"\n",(0,o.jsxs)(n.p,{children:["Initial data for a ",(0,o.jsx)(n.code,{children:"SpatialHashEnvironment"})," can be imported by specifying a file in the model's configuration file ",(0,o.jsx)(n.em,{children:"config.json"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'Previous section...\n"layers": [  \n  {  \n\t"name":"MyGridLayer",  \n\t"file": "Resources/grid.csv"\n  }\n]\nNext section...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"layers"}),", the grid environment ",(0,o.jsx)(n.code,{children:"MyGridLayer"})," receives initial information to be inserted into its grid cells via with initialization file ",(0,o.jsx)(n.code,{children:"grid.csv"}),". For example, in the wolf-sheep-grass model, this information can represent the initial amount of grass per grid cell (e.g., as an integer or double). For an example of an initialization file for a grid environment, please click ",(0,o.jsx)(n.a,{href:"https://git.haw-hamburg.de/mars/model-deployments/-/blob/master/C%23%20Models/Grid_Test%20CS/Grid_Test%20CS/Resources/grid.csv",children:"here"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Within the ",(0,o.jsx)(n.code,{children:"InitLayer(...)"})," method of the ",(0,o.jsx)(n.code,{children:"MyGridLayer"})," class, the data can be loaded as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"GridEnvironment = new SpatialHashEnvironment<Sheep>(Height, Width);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If the class name matches the name of the layer in config.json (i.e., ",(0,o.jsx)(n.code,{children:"MyGridLayer"})," in the above example), then the MARS runtime system obtains values for properties such as ",(0,o.jsx)(n.code,{children:"Height"})," and ",(0,o.jsx)(n.code,{children:"Width"})," from the referenced CSV file and integrate the data from the file into the environment."]}),"\n",(0,o.jsxs)(n.p,{children:["The above code snippet can be used to integrate input data from a file (e.g., a CSV file) into the environment. For more information and an example, please see ",(0,o.jsx)(n.a,{href:"https://git.haw-hamburg.de/mars/model-deployments/-/blob/master/C%23%20Models/Grid_Test%20CS/Grid_Test%20CS/Model/MyGridLayer.cs",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"exporting-data-for-a-grid-environment",children:"Exporting data for a Grid Environment"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"SpatialHashEnvironment"})," can be exported to a number of output formats. In the below example, CSV and JSON are illustrated."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'File.WriteAllText("gridEnvironment.csv", environment.ToCsv());\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'File.WriteAllText("gridEnvironment.json", environment.ToJson());\n'})}),"\n",(0,o.jsx)(n.h2,{id:"special-cases",children:"Special Cases"}),"\n",(0,o.jsx)(n.h3,{id:"how-to-calculate-a-bearing",children:"How to Calculate a Bearing"}),"\n",(0,o.jsxs)(n.p,{children:["The Cartesian bearing (in degrees) between two Cartesian coordinates is the angle between them relative to the ",(0,o.jsx)(n.code,{children:"UP"})," position. The ",(0,o.jsx)(n.code,{children:"UP"})," position points north and its bearing is equal to 0.0. From there, the size the angle increases in the clockwise direction."]}),"\n",(0,o.jsx)(n.p,{children:"The following two methods can be used to calculate a bearing between two positions. The first method takes the two positions directly, whereas the second method takes the individual coordinates of each position (as doubles)."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var bearing = GetBearingCartesian(<start_position>, <goal_position>)\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var bearing = CalculateBearingCartesian(<start_x>, <start_y>, <goal_x>, <goal_y>)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(96540);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);