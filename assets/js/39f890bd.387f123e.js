"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1862],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,k=c["".concat(s,".").concat(d)]||c[d]||h[d]||r;return n?a.createElement(k,o(o({ref:t},m),{},{components:n})):a.createElement(k,o({ref:t},m))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},50818:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_position:30},o="Collision Environment",l={unversionedId:"tutorial/development/environments/collisionenv",id:"tutorial/development/environments/collisionenv",title:"Collision Environment",description:"A CollisionEnvironment is a game environment that manages characters and obstacles. A character is an agent that participates in the game that is played in the environment (for more information on Character, click here). An obstacle is a physical object with a given geometric shape that is positioned in the environment (for more information on Obstacle, click here). The environment can handle different collision types, each described by a CollisionKind (for more information on CollisionKind, click here). A simple example showing a few functionalities can be found here.",source:"@site/docs/tutorial/development/environments/collisionenv.md",sourceDirName:"tutorial/development/environments",slug:"/tutorial/development/environments/collisionenv",permalink:"/docs/tutorial/development/environments/collisionenv",draft:!1,editUrl:"https://github.com/MARS-Group-HAW/MARS-Group-HAW.github.io/edit/main/docs/tutorial/development/environments/collisionenv.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"SpatialGraphEnvironment (SGE)",permalink:"/docs/tutorial/development/environments/spatialgraphenv"},next:{title:"Known Problems and Solutions",permalink:"/docs/tutorial/development/known-problems"}},s={},p=[{value:"Creating an environment",id:"creating-an-environment",level:2},{value:"Interaction with/within the <code>CollisionEnvironment</code>",id:"interaction-withwithin-the-collisionenvironment",level:2},{value:"Add a character to the environment",id:"add-a-character-to-the-environment",level:3},{value:"Remove an existing object",id:"remove-an-existing-object",level:3},{value:"Move an agent to another location",id:"move-an-agent-to-another-location",level:3},{value:"Explore other characters and obstacles",id:"explore-other-characters-and-obstacles",level:2},{value:"Exporting data for a Grid Environment",id:"exporting-data-for-a-grid-environment",level:2},{value:"Character",id:"character",level:2},{value:"Obstacle",id:"obstacle",level:2}],m={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"collision-environment"},"Collision Environment"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment")," is a game environment that manages characters and obstacles. A character is an agent that participates in the game that is played in the environment (for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"Character"),", click ",(0,i.kt)("a",{parentName:"p",href:"#character"},"here"),"). An obstacle is a physical object with a given geometric shape that is positioned in the environment (for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"Obstacle"),", click ",(0,i.kt)("a",{parentName:"p",href:"#obstacle"},"here"),"). The environment can handle different collision types, each described by a ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionKind")," (for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionKind"),", click ",(0,i.kt)("a",{parentName:"p",href:"#character"},"here"),"). A simple example showing a few functionalities can be found ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/tree/master/C%23%20Models/Collision_Test%20CS"},"here"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"While a ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment")," does not feature agents and entities, it has characters and obstacles. A character corresponds to an agent, and an obstacle corresponds to an entity. Characters can interact with obstacles, similar to how agents can interact with entities.")),(0,i.kt)("h2",{id:"creating-an-environment"},"Creating an environment"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment")," does not have a layer in the usual sense. The spatial extent of a ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment")," can be specified explicitly via a bounding box. If no bounding box is defined, the spatial extent is defined dynamically based on the positions of the obstacles."),(0,i.kt)("p",null,"Initialization occurs as shown in the following code snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var environment = new CollisionEnvironment<Player, Obstacle>();\n")),(0,i.kt)("p",null,"If an explicit spatial extent is desired, it can be specified via a bounding box as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"environment.BoundingBox = new BoundingBox(new Position(0, 0), new Position(9, 9));\n")),(0,i.kt)("p",null,"Here, the character type ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"IPlayer")," and the obstacle type ",(0,i.kt)("inlineCode",{parentName:"p"},"Obstacle")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"IObstacle"),"."),(0,i.kt)("p",null,"It is possible to load geometries to create a desired playground within ",(0,i.kt)("inlineCode",{parentName:"p"},"environment"),". The following two code snippets provide examples for generating geometries: a line string and a polygon."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var lineString = new LineString(new[] {\n  new Coordinate(5,5), \n  new Coordinate(8,8) \n});\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var polygon = new Polygon(new LinearRing(new[]  \n{  \n  new Coordinate(1,1),  \n  new Coordinate(2,3),  \n  new Coordinate(3,3),  \n  new Coordinate(1,1)  \n}));\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"environment_with_two_obstacles",src:n(1451).Z,width:"4110",height:"4620"})),(0,i.kt)("th",{parentName:"tr",align:null},"Fig.1: Illustration of a possible ",(0,i.kt)("inlineCode",{parentName:"th"},"CollisionEnvironment")," with a bounding box spanning the coordinates between ",(0,i.kt)("span",{parentName:"th",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mn",{parentName:"mrow"},"0"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"0"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(0,0)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," and ",(0,i.kt)("span",{parentName:"th",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mn",{parentName:"mrow"},"9"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"9"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(9,9)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},"9"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"9"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),". The environment holds the obstacles generated in the two above code snippets. The red line represents ",(0,i.kt)("inlineCode",{parentName:"th"},"lineString")," and the blue triangle represents ",(0,i.kt)("inlineCode",{parentName:"th"},"polygon"),".")))),(0,i.kt)("p",null,"The two generated geometries can be inserted into the environment as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"environment.Insert(new Obstacle(), polygon);  \nenvironment.Insert(new Obstacle(), lineString);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"environment")," consists of a graph (made up of nodes and edges) that holds inserted obstacles at their specified positions. A node is a ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingPoint")," and an edge is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Route"),". A set of routing points can be arranged evenly (as shown in Fig.1) with a slight offset (as shown in Fig.2) in a grid structure."),(0,i.kt)("p",null,"TODO: Einstellungsparameter f\xfcr Environment-Initialisierung finden und hier dokumentieren."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"environment_full",src:n(14442).Z,width:"941",height:"907"})),(0,i.kt)("th",{parentName:"tr",align:null},"Fig.2: Illustration of a possible ",(0,i.kt)("inlineCode",{parentName:"th"},"CollisionEnvironment")," with a spatial extent that was generated dynamically based on the positioning of the obstacles. The routing points that have a slight offset. The edges represent possible paths through the environment. The purple boxes represent obstacles.")))),(0,i.kt)("p",null,"The offset can be introduced as follows. Here, a total of ",(0,i.kt)("inlineCode",{parentName:"p"},"225")," routing points are distributed homogeneously across the ",(0,i.kt)("inlineCode",{parentName:"p"},"environment")," with an offset per routing point of ",(0,i.kt)("inlineCode",{parentName:"p"},"0.05"),". The resulting distribution of routing points can look like the set of routing points shown in Fig.2."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"environment.RoutingPointsGenerator =\n    new HomogenousRoutingPointsGenerator(225, 0.05);\n")),(0,i.kt)("p",null,"Alternatively to the homogeneous distributions shown in Fig.1 and Fig.2, a set of routing points that are distributed heterogeneously in space can be defined as follows. Here, a previously defined bounding box is divided into ",(0,i.kt)("inlineCode",{parentName:"p"},"20")," sections and ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," routing points per section."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"environment.RoutingPointsGenerator =\n    new SectionalRandomRoutingPointsGenerator(20, 5);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," In all cases, the modeller is responsible for the correct positioning of characters within the ",(0,i.kt)("inlineCode",{parentName:"p"},"environment"),". Therefore, it is advisable to position obstacles first (thereby generating the spatial extent of the environment) and then positioning characters such that they are situated within that spatial extent."),(0,i.kt)("h2",{id:"interaction-withwithin-the-collisionenvironment"},"Interaction with/within the ",(0,i.kt)("inlineCode",{parentName:"h2"},"CollisionEnvironment")),(0,i.kt)("h3",{id:"add-a-character-to-the-environment"},"Add a character to the environment"),(0,i.kt)("p",null,"To add a ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"environment"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert()")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," is used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Position = RandomPosition();\nEnvironment.Insert(this);\n")),(0,i.kt)("p",null,"This example takes place in the initialization method of a character ",(0,i.kt)("inlineCode",{parentName:"p"},"Player"),". The character has a property ",(0,i.kt)("inlineCode",{parentName:"p"},"Position"),". This property is initialized with a random position that consists of a tuple ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"y"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(x,y)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),". Once the character has a defined position, it can be placed on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," by calling the environment's ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert(<object reference>)")," method and passing a reference to the character."),(0,i.kt)("h3",{id:"remove-an-existing-object"},"Remove an existing object"),(0,i.kt)("p",null,"Removing a character follows the same principle as adding it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Remove(<object to remove>)")," method is executed via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," and the entity to be removed is specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.Remove(<object to remove>);\n")),(0,i.kt)("h3",{id:"move-an-agent-to-another-location"},"Move an agent to another location"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," can call the ",(0,i.kt)("inlineCode",{parentName:"p"},"Move(...)")," method of a ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment")," to move through the environment, as shown in the following code snippet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.Move(this, <bearing>, <distance>)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<bearing>")," is a double between 0.0 and 360.0 that specifies the direction in which the ",(0,i.kt)("inlineCode",{parentName:"li"},"Player")," wants to move. Here, 0.0 means a direction that points north. The direction of a value that is larger than 0.0 is determined by turning in a clock-wise direction from the north-facing direction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<distance>")," is a double that defines the number of units that the ",(0,i.kt)("inlineCode",{parentName:"li"},"Player")," wants to move in the direction specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"<bearing>"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The actual movement trajectory of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," depends on the properties of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Obstacle")," objects (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionKind"),") that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," might encounter on the desired path trajectory specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"<bearing>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<distance>"),". For more information on obstacles, please see (for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionKind"),", click ",(0,i.kt)("a",{parentName:"p",href:"#character"},"here"),")."),(0,i.kt)("p",null,"In addition to movement via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Move(...)")," method, a route between two ",(0,i.kt)("inlineCode",{parentName:"p"},"RoutingPoints")," can be specified via the ",(0,i.kt)("inlineCode",{parentName:"p"},"FindRoute(...)")," method as follows. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var route = environment.FindRoute(character, goal).ToList();\n")),(0,i.kt)("p",null,"This call returns a route, which is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Position")," objects. The route specifies a path through the environment from the current position of ",(0,i.kt)("inlineCode",{parentName:"p"},"character")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"goal"),"."),(0,i.kt)("h2",{id:"explore-other-characters-and-obstacles"},"Explore other characters and obstacles"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Player")," can explore other characters and obstacles in the environment as shown in the following two code snippets."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var exploredCharacters = environment.ExploreCharacters(<source>, <geometry>, <predicate>)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var exploredObstacles = environment.ExploreObstacles(<geometry>, <predicate>)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ExploreCharacters(...)")," returns a list of characters, where ",(0,i.kt)("inlineCode",{parentName:"li"},"<source>")," is the requesting character, ",(0,i.kt)("inlineCode",{parentName:"li"},"<geometry>")," is the spatial area of exploration, and ",(0,i.kt)("inlineCode",{parentName:"li"},"<predicate>")," is an optional filter criterion that can be set to filter the returned collection. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ExploreCharacters(...)")," returns a list of obstacles, where ",(0,i.kt)("inlineCode",{parentName:"li"},"<geometry>")," is the spatial area of exploration and ",(0,i.kt)("inlineCode",{parentName:"li"},"<predicate>")," is an optional filter criterion that can be set to filter the returned collection. ")),(0,i.kt)("h2",{id:"exporting-data-for-a-grid-environment"},"Exporting data for a Grid Environment"),(0,i.kt)("p",null,"TODO"),(0,i.kt)("h2",{id:"character"},"Character"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Character")," is an active participant of the game that is played in a ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionEnvironment"),". It is described by the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ID"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Guid")," that uniquely identifies a ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Position"),": The current position, described by a tuple ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"y"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(x,y)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),", of a ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Extent"),": The spatial extent of a ",(0,i.kt)("inlineCode",{parentName:"li"},"Character"))),(0,i.kt)("p",null,"Furthermore, the following method is inherent to every ",(0,i.kt)("inlineCode",{parentName:"p"},"Character"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HandleCollision(ICharacter other)"),": This method is called by a ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," upon collision with ",(0,i.kt)("inlineCode",{parentName:"li"},"ICharacter")," (a collision between two characters). It returns a ",(0,i.kt)("inlineCode",{parentName:"li"},"CollisionKind")," that represents the action that the ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," should take as a result of the collision.")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"CollisionKind")," can be one of three actions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Block"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," blocks ",(0,i.kt)("inlineCode",{parentName:"li"},"other"),", i.e., acts like a obstacle for that ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pass"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," moves through ",(0,i.kt)("inlineCode",{parentName:"li"},"other"),", i.e., continues along its original movement trajectory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Remove"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," is removed from the environment due to the collision")),(0,i.kt)("h2",{id:"obstacle"},"Obstacle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IsRoutable(ICharacter)"),": returns a boolean that states whether ",(0,i.kt)("inlineCode",{parentName:"li"},"ICharacter")," is a blocking object or can be passed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HandleCollision(ICharacter)"),": This method is called by an ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle")," when ",(0,i.kt)("inlineCode",{parentName:"li"},"ICharacter")," collides with it. It returns a ",(0,i.kt)("inlineCode",{parentName:"li"},"CollisionKind")," that represents the role that the ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle")," should play in the context of the movement behavior of ",(0,i.kt)("inlineCode",{parentName:"li"},"ICharacter"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HandleExploration(ICharacter)"),": This method handles the visibility check for the ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle")," by returning the ",(0,i.kt)("inlineCode",{parentName:"li"},"VisibilityKind")," of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle"))),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"VisibilityKind")," describes whether an ",(0,i.kt)("inlineCode",{parentName:"p"},"Obstacle")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Transparent")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Opaque")," with respect to the vision of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Character"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Transparent"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," can see through the ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Opaque"),": A ",(0,i.kt)("inlineCode",{parentName:"li"},"Character")," cannot see through the ",(0,i.kt)("inlineCode",{parentName:"li"},"Obstacle"))))}c.isMDXComponent=!0},14442:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/environment_full-1c0ed42cc222e841117783bc6bafd07a.png"},1451:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/environment_with_two_obstacles-954a7315e5dfcb4954fd21982c732702.png"}}]);