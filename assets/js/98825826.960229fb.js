"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2556],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,u=d["".concat(s,".").concat(c)]||d[c]||h[c]||o;return n?a.createElement(u,r(r({ref:t},m),{},{components:n})):a.createElement(u,r({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},46358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_position:10},r="GeoHashEnvironment (Geospatial Grid Environment)",l={unversionedId:"tutorial/development/environments/geohashenv",id:"tutorial/development/environments/geohashenv",title:"GeoHashEnvironment (Geospatial Grid Environment)",description:"A geospatial environment is an environment that consists of geospatial point objects. A geospatial point objects is a georeferenced location that consists of a longitude and latitude, in this case based on the coordinate reference system WGS84 EPSG:4326 CRS. A simple example showing a few functionalities can be found here.",source:"@site/docs/tutorial/development/environments/geohashenv.md",sourceDirName:"tutorial/development/environments",slug:"/tutorial/development/environments/geohashenv",permalink:"/docs/tutorial/development/environments/geohashenv",draft:!1,editUrl:"https://github.com/daniel260/theraflow-doc/edit/main/docs/tutorial/development/environments/geohashenv.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"SpatialHashEnvironment (Grid Environment)",permalink:"/docs/tutorial/development/environments/spatialhashenv"},next:{title:"SpatialGraphEnvironment (SGE)",permalink:"/docs/tutorial/development/environments/spatialgraphenv"}},s={},p=[{value:"Creating an environment",id:"creating-an-environment",level:2},{value:"Interaction with/within the Grid Environment",id:"interaction-withwithin-the-grid-environment",level:2},{value:"Add an agents to the environment",id:"add-an-agents-to-the-environment",level:3},{value:"Remove an existing object",id:"remove-an-existing-object",level:3},{value:"Move an agent to another location",id:"move-an-agent-to-another-location",level:3},{value:"Explore other agents and resources",id:"explore-other-agents-and-resources",level:2},{value:"Importing data for a GeoHashEnvironment",id:"importing-data-for-a-geohashenvironment",level:2},{value:"Exporting data for a Geo Environment",id:"exporting-data-for-a-geo-environment",level:2},{value:"Special Cases",id:"special-cases",level:2},{value:"How to Calculate a Bearing",id:"how-to-calculate-a-bearing",level:3}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"geohashenvironment-geospatial-grid-environment"},"GeoHashEnvironment (Geospatial Grid Environment)"),(0,i.kt)("p",null,"A geospatial environment is an environment that consists of geospatial point objects. A geospatial point objects is a georeferenced location that consists of a longitude and latitude, in this case based on the coordinate reference system WGS84 EPSG:4326 CRS. A simple example showing a few functionalities can be found ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/tree/master/C%23%20Models/Geo_Test%20CS"},"here"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," uses the Geohash encoding to store point data. Objects are inserted into a tree and can be queried against a given spatial window query, such as k-NN or just a point query."),(0,i.kt)("h2",{id:"creating-an-environment"},"Creating an environment"),(0,i.kt)("p",null,"Creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," can be done by specifying the geographic region to cover. For example, create a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," for the city centre of Hamburg, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"BuildByBBox()")," method. This method requires a bounding box."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var environment = GeoHashEnvironment<Citizen>.BuildByBBox(9.908253, 53.510570, 10.100194, 53.602103);\n")),(0,i.kt)("p",null,"In this example, a bounding box with lower-left bound (lon:9.908253,lat:53.510570) and upper-right bound (lon:10.100194,lat:53.602103) is specified. The agent type ",(0,i.kt)("inlineCode",{parentName:"p"},"Citizen")," lives on this layer, as specified in the initialization signature."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Alternatively, a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," can be initialized using geospatial data that is loaded into the simulation at runtime. Doing so changes the initialization routine of the layer type, as shown ",(0,i.kt)("a",{parentName:"p",href:"#importing-data-for-a-geohashenvironment"},"below"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Optionally, the precision of the environment can be specified using the parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"cellSizeInM"),". The smaller the cell size, the more precise the coordinate computation, but the slower the simulation execution."),(0,i.kt)("p",null,"The choice of the cell size depends mainly on the size of a time step. For example, for a simulation with a temporal reference (i.e., the simulation's start time and end time are specified using real dates and/or times) with a time step equal to 1 second, a cell size of 1 meter (default when no argument was passed) is recommended. With an increased time step, e.g. 1 minute, the cell size should be proportionally larger to maintain the realism of individual movement of objects."),(0,i.kt)("h2",{id:"interaction-withwithin-the-grid-environment"},"Interaction with/within the Grid Environment"),(0,i.kt)("h3",{id:"add-an-agents-to-the-environment"},"Add an agents to the environment"),(0,i.kt)("p",null,"To add an object (for example, an agent or entity) to a georeferenced environment, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," is used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Position = Position.CreateGeoPosition(<longitude>, <latitude>);\nEnvironment.Insert(this);\n")),(0,i.kt)("p",null,"This example takes place in the initialization method of an agent ",(0,i.kt)("inlineCode",{parentName:"p"},"Citizen"),". The agent has a property ",(0,i.kt)("inlineCode",{parentName:"p"},"Position"),". This property is initialized with a geoposition that consists of a tuple ",(0,i.kt)("inlineCode",{parentName:"p"},"(<longitude>,<latitude>)"),". These values can be imported from an agent initialization file (typically a CSV file; see documentation on ",(0,i.kt)("a",{parentName:"p",href:"/docs/tutorial/development/agent"},"Agents")," for more details). Once the agent has a defined position, it can be placed on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," by calling the environment's ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert(<object reference>)")," method and passing a reference to the agent."),(0,i.kt)("h3",{id:"remove-an-existing-object"},"Remove an existing object"),(0,i.kt)("p",null,"Removing an agent follows the same principle as adding it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Remove(<object to remove>)")," method is executed via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," and the entity to be removed is specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.Remove(this);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Alternatively, an agent can be removed from the layer on which the agent lives by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"UnregisterAgent")," method of the layer. This method, in turn, has a method ",(0,i.kt)("inlineCode",{parentName:"p"},"Invoke()"),", which takes the layer from which the agent should be removed and a reference to the agent that should be removed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.UnregisterAgent.Invoke(Environment, this);\n")),(0,i.kt)("h3",{id:"move-an-agent-to-another-location"},"Move an agent to another location"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," enables agents to move on it. There are four movement methods, which are illustrated in the following examples."),(0,i.kt)("p",null,"The first movement method is ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTo()"),", which is called as shown below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTo(this, <position tuple (longitude, latitude)>);\n")),(0,i.kt)("p",null,"Upon execution of the above code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," determines the shortest path between the agent's current position and the goal position specified in the method's second parameter."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," There are different options for the second parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTo()"),". Alternatively to the tuple shown above, the method can take two individual double values ","\u2013"," representing the longitude and latitude of the desired position, respectively ","\u2013"," as the second and third parameter. Or an array of double values can be passed to represent a path which the agent should travel along."),(0,i.kt)("p",null,"The second movement method is ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTowards()"),", which has two signatures. This method can be called either with a ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectionType")," enum or with a bearing double. For more information on how to calculate a bearing, please see ",(0,i.kt)("a",{parentName:"p",href:"#how-to-calculate-a-bearing"},"here"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTowards(this, <DirectionType>);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTowards(this, <bearing>);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectionType")," enum can be ",(0,i.kt)("inlineCode",{parentName:"p"},"Up"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Down"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpRight"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpLeft"),", etc. The bearing can be a double between 0.0 (equivalent to the direction type ",(0,i.kt)("inlineCode",{parentName:"p"},"Up"),") and 360.0 and specifies the angle to which the agent should turn and move."),(0,i.kt)("p",null,"The last movement method is ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveToPosition()"),". This method takes a reference to the object (agent or entity) that should be re-positioned and a latitude and longitude. It returns a position object, allowing the agent to be positioned at the respective position by overwriting its ",(0,i.kt)("inlineCode",{parentName:"p"},"Position")," property. ",(0,i.kt)("strong",{parentName:"p"},"Note:"),' this function allows agents to be "teleported" to any given position on the environment.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveToPosition(this, <latitude>, <longitude>);\n")),(0,i.kt)("h2",{id:"explore-other-agents-and-resources"},"Explore other agents and resources"),(0,i.kt)("p",null,"Agents can explore an environment to identify other agents and resources by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore()")," method on the environment. Below is an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Citizen> result = Environment.Explore();\n")),(0,i.kt)("p",null,"This call explores the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Citizen")," agents. Since no parameters are specified, the entire ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," is explored. ",(0,i.kt)("strong",{parentName:"p"},"Note: in simulations with many agents, this can be computationally costly.")),(0,i.kt)("p",null,"Alternatively, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore()")," method can also be called with parameters. The signature is ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore(<position>, <search_radius>, <number_of_objects>, <filter_predicate>)"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"position")," is the geospatial position (consisting of an ",(0,i.kt)("inlineCode",{parentName:"li"},"longitude")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"latitude"),") from which the exploration should begin (e.g., the caller's current position)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<search_radius>")," is the extent of the exploration (e.g., an ",(0,i.kt)("inlineCode",{parentName:"li"},"Explore()")," call with a search radius of ",(0,i.kt)("inlineCode",{parentName:"li"},"5")," on a geohash environment explores the environment within five grid cells of the specified ",(0,i.kt)("inlineCode",{parentName:"li"},"<position>"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<number_of_objects>")," is the maximum number of objects (i.e., ",(0,i.kt)("inlineCode",{parentName:"li"},"Citizen")," agents, in case of the current example) that should be returned as a result of the exploration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<filter_predicate>")," is an optional predicate (selection expression) that can be applied to the exploration goal (in this case ",(0,i.kt)("inlineCode",{parentName:"li"},"Citizen")," agents) in case only those agents that satisfy a certain condition are required. Below is an example of a full ",(0,i.kt)("inlineCode",{parentName:"li"},"Explore()")," call.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Citizen> result = Environment.Explore(Position, 20, -1, agentInEnvironment => agentInEnvironment.HasBike);\n")),(0,i.kt)("p",null,"In this example, all ",(0,i.kt)("inlineCode",{parentName:"p"},"Citizen")," agents within ",(0,i.kt)("inlineCode",{parentName:"p"},"20")," steps that satisfy the ",(0,i.kt)("inlineCode",{parentName:"p"},"HasBike")," condition are returned and stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable")," collection. By specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," in the second parameter, the results are not limited by search radius."),(0,i.kt)("p",null,"Furthermore, if you want to query the entire spatial space, you specify ",(0,i.kt)("inlineCode",{parentName:"p"},"-1D")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"<radius>"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Citizen> result = Environment.Explore(Position, -1D, -1, agentInEnvironment => agentInEnvironment.HasBike);\n")),(0,i.kt)("p",null,"In this case, all registered ",(0,i.kt)("inlineCode",{parentName:"p"},"Citizen")," agents in the environment are queried for the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"HasBike"),". However, the filter specified in the fourth parameter is still applied to potentially filter the results based on whether the agents satisfy the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"HasBike"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Alternatively, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Select()")," and other LINQ queries can be formulated on the ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<Citizen> result"),", which will be evaluated after the query is executed."),(0,i.kt)("h2",{id:"importing-data-for-a-geohashenvironment"},"Importing data for a GeoHashEnvironment"),(0,i.kt)("p",null,"The bounding box of a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," is defined based on a set of data that define the geospatial extent of the simulation environment of interest. For example, this can be an ASC file that covers the Hamburg metropolitan area. This file can be loaded into the simulation via the model's configuration file ",(0,i.kt)("em",{parentName:"p"},"config.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'Previous section...\n"layers": [  \n  {  \n    "name":"MyGeoHashLayer",  \n    "file": "Resources/hamburg.asc"\n  }\n]\nNext section...\n')),(0,i.kt)("p",null,"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGeoHashLayer")," is loaded into the simulation from the configuration file, a property with the same name is required in the layer class. This requires an annotation ",(0,i.kt)("inlineCode",{parentName:"p"},"[PropertyDescription]")," above the property name, indicating to the runtime system that external information is available to be written into the property at runtime. For more information on layer initialization and annotations, please click ",(0,i.kt)("a",{parentName:"p",href:"https://mars.haw-hamburg.de/articles/core/basic-concepts/layers.html"},"here"),"."),(0,i.kt)("p",null,"Then, an environment can be initialized as follows (typically in the initialization method of the layer):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var extent = new Envelope(MyGeoHashLayer.Extent);\nvar environment = GeoHashEnvironment<Citizen>.BuildByBBox(new BoundingBox(extent), <cellSizeInM>);\n")),(0,i.kt)("p",null,"By calling the property ",(0,i.kt)("inlineCode",{parentName:"p"},"Extent"),", the geographic extent that is represented in the property ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGeoHashLayer")," is stored in a local variable ",(0,i.kt)("inlineCode",{parentName:"p"},"extent"),". This information is then used to initialize a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," with a bounding box that is equivalent to the geographic extent stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"extent"),". Here, the parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"cellSizeInM")," is required and denotes the size of an individual cell of the ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," in meters."),(0,i.kt)("p",null,"For more information and an example of how to generate an abstract environment with a spatial extent that is made up of multiple layers, please see ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/blob/master/C%23%20Models/Geo_Test%20CS/Geo_Test%20CS/Model/LandscapeLayer.cs"},"here"),"."),(0,i.kt)("h2",{id:"exporting-data-for-a-geo-environment"},"Exporting data for a Geo Environment"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GeoHashEnvironment")," can be exported to a number of output formats. In the below example, CSV and JSON are illustrated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'File.WriteAllText("geoEnvironment.csv", environment.ToCsv());\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'File.WriteAllText("geoEnvironment.json", environment.ToJson());\n')),(0,i.kt)("h2",{id:"special-cases"},"Special Cases"),(0,i.kt)("h3",{id:"how-to-calculate-a-bearing"},"How to Calculate a Bearing"),(0,i.kt)("p",null,"The bearing (in degrees) between two geographic coordinates is the angle between them relative to the ",(0,i.kt)("inlineCode",{parentName:"p"},"UP")," position. The ",(0,i.kt)("inlineCode",{parentName:"p"},"UP")," position points north and its bearing is equal to 0.0. From there, the size the angle increases in the clockwise direction."),(0,i.kt)("p",null,"The following two methods can be used to calculate a bearing between two positions. The first method takes the two positions directly, whereas the second method takes the individual coordinates of each position (as doubles)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var bearing = GetBearing(this Position pt1, in Position pt2)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var bearing = GetBearing(double x1, double y1, double x2, double y2)\n")))}d.isMDXComponent=!0}}]);