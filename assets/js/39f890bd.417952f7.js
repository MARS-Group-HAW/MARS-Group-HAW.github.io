"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8720],{62306:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial/development/environments/collisionenv","title":"Collision Environment","description":"A CollisionEnvironment is a game environment that manages characters and obstacles. A character is an agent that participates in the game that is played in the environment (for more information on Character, click here). An obstacle is a physical object with a given geometric shape that is positioned in the environment (for more information on Obstacle, click here). The environment can handle different collision types, each described by a CollisionKind (for more information on CollisionKind, click here). A simple example showing a few functionalities can be found here.","source":"@site/docs/tutorial/development/environments/collisionenv.md","sourceDirName":"tutorial/development/environments","slug":"/tutorial/development/environments/collisionenv","permalink":"/docs/tutorial/development/environments/collisionenv","draft":false,"unlisted":false,"editUrl":"https://github.com/MARS-Group-HAW/MARS-Group-HAW.github.io/edit/main/docs/tutorial/development/environments/collisionenv.md","tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30},"sidebar":"tutorialSidebar","previous":{"title":"SpatialGraphEnvironment (SGE)","permalink":"/docs/tutorial/development/environments/spatialgraphenv"},"next":{"title":"Known Problems and Solutions","permalink":"/docs/tutorial/development/known-problems"}}');var t=i(74848),r=i(28453);const a={sidebar_position:30},o="Collision Environment",c={},l=[{value:"Creating an environment",id:"creating-an-environment",level:2},{value:"Interaction with/within the <code>CollisionEnvironment</code>",id:"interaction-withwithin-the-collisionenvironment",level:2},{value:"Add a character to the environment",id:"add-a-character-to-the-environment",level:3},{value:"Remove an existing object",id:"remove-an-existing-object",level:3},{value:"Move an agent to another location",id:"move-an-agent-to-another-location",level:3},{value:"Explore other characters and obstacles",id:"explore-other-characters-and-obstacles",level:2},{value:"Exporting data for a Grid Environment",id:"exporting-data-for-a-grid-environment",level:2},{value:"Character",id:"character",level:2},{value:"Obstacle",id:"obstacle",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"collision-environment",children:"Collision Environment"})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," is a game environment that manages characters and obstacles. A character is an agent that participates in the game that is played in the environment (for more information on ",(0,t.jsx)(n.code,{children:"Character"}),", click ",(0,t.jsx)(n.a,{href:"#character",children:"here"}),"). An obstacle is a physical object with a given geometric shape that is positioned in the environment (for more information on ",(0,t.jsx)(n.code,{children:"Obstacle"}),", click ",(0,t.jsx)(n.a,{href:"#obstacle",children:"here"}),"). The environment can handle different collision types, each described by a ",(0,t.jsx)(n.code,{children:"CollisionKind"})," (for more information on ",(0,t.jsx)(n.code,{children:"CollisionKind"}),", click ",(0,t.jsx)(n.a,{href:"#character",children:"here"}),"). A simple example showing a few functionalities can be found ",(0,t.jsx)(n.a,{href:"https://git.haw-hamburg.de/mars/model-deployments/-/tree/master/C%23%20Models/Collision_Test%20CS",children:"here"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["While a ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," does not feature agents and entities, it has characters and obstacles. A character corresponds to an agent, and an obstacle corresponds to an entity. Characters can interact with obstacles, similar to how agents can interact with entities."]})}),"\n",(0,t.jsx)(n.h2,{id:"creating-an-environment",children:"Creating an environment"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," does not have a layer in the usual sense. The spatial extent of a ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," can be specified explicitly via a bounding box. If no bounding box is defined, the spatial extent is defined dynamically based on the positions of the obstacles."]}),"\n",(0,t.jsx)(n.p,{children:"Initialization occurs as shown in the following code snippet."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var environment = new CollisionEnvironment<Player, Obstacle>();\n"})}),"\n",(0,t.jsx)(n.p,{children:"If an explicit spatial extent is desired, it can be specified via a bounding box as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"environment.BoundingBox = new BoundingBox(new Position(0, 0), new Position(9, 9));\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, the character type ",(0,t.jsx)(n.code,{children:"Player"})," implements ",(0,t.jsx)(n.code,{children:"IPlayer"})," and the obstacle type ",(0,t.jsx)(n.code,{children:"Obstacle"})," implements ",(0,t.jsx)(n.code,{children:"IObstacle"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It is possible to load geometries to create a desired playground within ",(0,t.jsx)(n.code,{children:"environment"}),". The following two code snippets provide examples for generating geometries: a line string and a polygon."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var lineString = new LineString(new[] {\n  new Coordinate(5,5), \n  new Coordinate(8,8) \n});\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var polygon = new Polygon(new LinearRing(new[]  \n{  \n  new Coordinate(1,1),  \n  new Coordinate(2,3),  \n  new Coordinate(3,3),  \n  new Coordinate(1,1)  \n}));\n"})}),"\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.img,{alt:"environment_with_two_obstacles",src:i(52374).A+"",width:"4110",height:"4620"})}),(0,t.jsxs)(n.th,{children:["Fig.1: Illustration of a possible ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," with a bounding box spanning the coordinates between ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"0"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mn,{children:"0"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(0,0)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"0"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord",children:"0"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})," and ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"9"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mn,{children:"9"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(9,9)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"9"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord",children:"9"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". The environment holds the obstacles generated in the two above code snippets. The red line represents ",(0,t.jsx)(n.code,{children:"lineString"})," and the blue triangle represents ",(0,t.jsx)(n.code,{children:"polygon"}),"."]})]})})}),"\n",(0,t.jsx)(n.p,{children:"The two generated geometries can be inserted into the environment as follows."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"environment.Insert(new Obstacle(), polygon);  \nenvironment.Insert(new Obstacle(), lineString);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"environment"})," consists of a graph (made up of nodes and edges) that holds inserted obstacles at their specified positions. A node is a ",(0,t.jsx)(n.code,{children:"RoutingPoint"})," and an edge is a ",(0,t.jsx)(n.code,{children:"Route"}),". A set of routing points can be arranged evenly (as shown in Fig.1) with a slight offset (as shown in Fig.2) in a grid structure."]}),"\n",(0,t.jsx)(n.p,{children:"TODO: Einstellungsparameter f\xfcr Environment-Initialisierung finden und hier dokumentieren."}),"\n",(0,t.jsx)(n.table,{children:(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.img,{alt:"environment_full",src:i(97741).A+"",width:"941",height:"907"})}),(0,t.jsxs)(n.th,{children:["Fig.2: Illustration of a possible ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," with a spatial extent that was generated dynamically based on the positioning of the obstacles. The routing points that have a slight offset. The edges represent possible paths through the environment. The purple boxes represent obstacles."]})]})})}),"\n",(0,t.jsxs)(n.p,{children:["The offset can be introduced as follows. Here, a total of ",(0,t.jsx)(n.code,{children:"225"})," routing points are distributed homogeneously across the ",(0,t.jsx)(n.code,{children:"environment"})," with an offset per routing point of ",(0,t.jsx)(n.code,{children:"0.05"}),". The resulting distribution of routing points can look like the set of routing points shown in Fig.2."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"environment.RoutingPointsGenerator =\n    new HomogenousRoutingPointsGenerator(225, 0.05);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively to the homogeneous distributions shown in Fig.1 and Fig.2, a set of routing points that are distributed heterogeneously in space can be defined as follows. Here, a previously defined bounding box is divided into ",(0,t.jsx)(n.code,{children:"20"})," sections and ",(0,t.jsx)(n.code,{children:"5"})," routing points per section."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"environment.RoutingPointsGenerator =\n    new SectionalRandomRoutingPointsGenerator(20, 5);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," In all cases, the modeller is responsible for the correct positioning of characters within the ",(0,t.jsx)(n.code,{children:"environment"}),". Therefore, it is advisable to position obstacles first (thereby generating the spatial extent of the environment) and then positioning characters such that they are situated within that spatial extent."]}),"\n",(0,t.jsxs)(n.h2,{id:"interaction-withwithin-the-collisionenvironment",children:["Interaction with/within the ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})]}),"\n",(0,t.jsx)(n.h3,{id:"add-a-character-to-the-environment",children:"Add a character to the environment"}),"\n",(0,t.jsxs)(n.p,{children:["To add a ",(0,t.jsx)(n.code,{children:"Player"})," to the ",(0,t.jsx)(n.code,{children:"environment"}),", the ",(0,t.jsx)(n.code,{children:"Insert()"})," method of the ",(0,t.jsx)(n.code,{children:"Environment"})," is used."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"Position = RandomPosition();\nEnvironment.Insert(this);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This example takes place in the initialization method of a character ",(0,t.jsx)(n.code,{children:"Player"}),". The character has a property ",(0,t.jsx)(n.code,{children:"Position"}),". This property is initialized with a random position that consists of a tuple ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"x"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mi,{children:"y"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(x,y)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". Once the character has a defined position, it can be placed on the ",(0,t.jsx)(n.code,{children:"Environment"})," by calling the environment's ",(0,t.jsx)(n.code,{children:"Insert(<object reference>)"})," method and passing a reference to the character."]}),"\n",(0,t.jsx)(n.h3,{id:"remove-an-existing-object",children:"Remove an existing object"}),"\n",(0,t.jsxs)(n.p,{children:["Removing a character follows the same principle as adding it. The ",(0,t.jsx)(n.code,{children:"Remove(<object to remove>)"})," method is executed via the ",(0,t.jsx)(n.code,{children:"Environment"})," and the entity to be removed is specified."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"Environment.Remove(<object to remove>);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"move-an-agent-to-another-location",children:"Move an agent to another location"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Player"})," can call the ",(0,t.jsx)(n.code,{children:"Move(...)"})," method of a ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"})," to move through the environment, as shown in the following code snippet."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"Environment.Move(this, <bearing>, <distance>)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<bearing>"})," is a double between 0.0 and 360.0 that specifies the direction in which the ",(0,t.jsx)(n.code,{children:"Player"})," wants to move. Here, 0.0 means a direction that points north. The direction of a value that is larger than 0.0 is determined by turning in a clock-wise direction from the north-facing direction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<distance>"})," is a double that defines the number of units that the ",(0,t.jsx)(n.code,{children:"Player"})," wants to move in the direction specified by ",(0,t.jsx)(n.code,{children:"<bearing>"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," The actual movement trajectory of a ",(0,t.jsx)(n.code,{children:"Player"})," depends on the properties of the ",(0,t.jsx)(n.code,{children:"Obstacle"})," objects (e.g., ",(0,t.jsx)(n.code,{children:"CollisionKind"}),") that the ",(0,t.jsx)(n.code,{children:"Player"})," might encounter on the desired path trajectory specified by ",(0,t.jsx)(n.code,{children:"<bearing>"})," and ",(0,t.jsx)(n.code,{children:"<distance>"}),". For more information on obstacles, please see (for more information on ",(0,t.jsx)(n.code,{children:"CollisionKind"}),", click ",(0,t.jsx)(n.a,{href:"#character",children:"here"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to movement via the ",(0,t.jsx)(n.code,{children:"Move(...)"})," method, a route between two ",(0,t.jsx)(n.code,{children:"RoutingPoints"})," can be specified via the ",(0,t.jsx)(n.code,{children:"FindRoute(...)"})," method as follows."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var route = environment.FindRoute(character, goal).ToList();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This call returns a route, which is a list of ",(0,t.jsx)(n.code,{children:"Position"})," objects. The route specifies a path through the environment from the current position of ",(0,t.jsx)(n.code,{children:"character"})," to ",(0,t.jsx)(n.code,{children:"goal"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"explore-other-characters-and-obstacles",children:"Explore other characters and obstacles"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Player"})," can explore other characters and obstacles in the environment as shown in the following two code snippets."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var exploredCharacters = environment.ExploreCharacters(<source>, <geometry>, <predicate>)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var exploredObstacles = environment.ExploreObstacles(<geometry>, <predicate>)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ExploreCharacters(...)"})," returns a list of characters, where ",(0,t.jsx)(n.code,{children:"<source>"})," is the requesting character, ",(0,t.jsx)(n.code,{children:"<geometry>"})," is the spatial area of exploration, and ",(0,t.jsx)(n.code,{children:"<predicate>"})," is an optional filter criterion that can be set to filter the returned collection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ExploreCharacters(...)"})," returns a list of obstacles, where ",(0,t.jsx)(n.code,{children:"<geometry>"})," is the spatial area of exploration and ",(0,t.jsx)(n.code,{children:"<predicate>"})," is an optional filter criterion that can be set to filter the returned collection."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exporting-data-for-a-grid-environment",children:"Exporting data for a Grid Environment"}),"\n",(0,t.jsx)(n.p,{children:"TODO"}),"\n",(0,t.jsx)(n.h2,{id:"character",children:"Character"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Character"})," is an active participant of the game that is played in a ",(0,t.jsx)(n.code,{children:"CollisionEnvironment"}),". It is described by the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ID"}),": A ",(0,t.jsx)(n.code,{children:"Guid"})," that uniquely identifies a ",(0,t.jsx)(n.code,{children:"Character"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Position"}),": The current position, described by a tuple ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"x"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mi,{children:"y"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"(x,y)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", of a ",(0,t.jsx)(n.code,{children:"Character"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Extent"}),": The spatial extent of a ",(0,t.jsx)(n.code,{children:"Character"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Furthermore, the following method is inherent to every ",(0,t.jsx)(n.code,{children:"Character"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"HandleCollision(ICharacter other)"}),": This method is called by a ",(0,t.jsx)(n.code,{children:"Character"})," upon collision with ",(0,t.jsx)(n.code,{children:"ICharacter"})," (a collision between two characters). It returns a ",(0,t.jsx)(n.code,{children:"CollisionKind"})," that represents the action that the ",(0,t.jsx)(n.code,{children:"Character"})," should take as a result of the collision."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CollisionKind"})," can be one of three actions:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Block"}),": A ",(0,t.jsx)(n.code,{children:"Character"})," blocks ",(0,t.jsx)(n.code,{children:"other"}),", i.e., acts like a obstacle for that ",(0,t.jsx)(n.code,{children:"Character"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Pass"}),": A ",(0,t.jsx)(n.code,{children:"Character"})," moves through ",(0,t.jsx)(n.code,{children:"other"}),", i.e., continues along its original movement trajectory"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Remove"}),": A ",(0,t.jsx)(n.code,{children:"Character"})," is removed from the environment due to the collision"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"obstacle",children:"Obstacle"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IsRoutable(ICharacter)"}),": returns a boolean that states whether ",(0,t.jsx)(n.code,{children:"ICharacter"})," is a blocking object or can be passed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"HandleCollision(ICharacter)"}),": This method is called by an ",(0,t.jsx)(n.code,{children:"Obstacle"})," when ",(0,t.jsx)(n.code,{children:"ICharacter"})," collides with it. It returns a ",(0,t.jsx)(n.code,{children:"CollisionKind"})," that represents the role that the ",(0,t.jsx)(n.code,{children:"Obstacle"})," should play in the context of the movement behavior of ",(0,t.jsx)(n.code,{children:"ICharacter"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"HandleExploration(ICharacter)"}),": This method handles the visibility check for the ",(0,t.jsx)(n.code,{children:"Obstacle"})," by returning the ",(0,t.jsx)(n.code,{children:"VisibilityKind"})," of the ",(0,t.jsx)(n.code,{children:"Obstacle"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"VisibilityKind"})," describes whether an ",(0,t.jsx)(n.code,{children:"Obstacle"})," is ",(0,t.jsx)(n.code,{children:"Transparent"})," or ",(0,t.jsx)(n.code,{children:"Opaque"})," with respect to the vision of a ",(0,t.jsx)(n.code,{children:"Character"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Transparent"}),": A ",(0,t.jsx)(n.code,{children:"Character"})," can see through the ",(0,t.jsx)(n.code,{children:"Obstacle"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Opaque"}),": A ",(0,t.jsx)(n.code,{children:"Character"})," cannot see through the ",(0,t.jsx)(n.code,{children:"Obstacle"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},97741:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/environment_full-1c0ed42cc222e841117783bc6bafd07a.png"},52374:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/environment_with_two_obstacles-954a7315e5dfcb4954fd21982c732702.png"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);