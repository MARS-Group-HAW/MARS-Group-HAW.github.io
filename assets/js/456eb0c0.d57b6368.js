"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2321],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(t),c=i,u=m["".concat(s,".").concat(c)]||m[c]||h[c]||o;return t?a.createElement(u,r(r({ref:n},d),{},{components:t})):a.createElement(u,r({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},93171:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const o={sidebar_position:1},r="SpatialHashEnvironment (Grid Environment)",l={unversionedId:"tutorial/development/environments/spatialhashenv",id:"tutorial/development/environments/spatialhashenv",title:"SpatialHashEnvironment (Grid Environment)",description:"A grid is an environment in which the world is divided into cells of equal size, like on a chessboard. An object (an agent or an entity) on the grid can be moved along the horizontal, vertical, and diagonal axes. A simple example showing a few functionalities can be found here.",source:"@site/docs/tutorial/development/environments/spatialhashenv.md",sourceDirName:"tutorial/development/environments",slug:"/tutorial/development/environments/spatialhashenv",permalink:"/docs/tutorial/development/environments/spatialhashenv",draft:!1,editUrl:"https://github.com/MARS-Group-HAW/MARS-Group-HAW.github.io/edit/main/docs/tutorial/development/environments/spatialhashenv.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Environments",permalink:"/docs/tutorial/development/environments/"},next:{title:"GeoHashEnvironment (Geospatial Grid Environment)",permalink:"/docs/tutorial/development/environments/geohashenv"}},s={},p=[{value:"Creating an environment",id:"creating-an-environment",level:2},{value:"Interaction with/within the Grid Environment",id:"interaction-withwithin-the-grid-environment",level:2},{value:"Add an agent to the environment",id:"add-an-agent-to-the-environment",level:3},{value:"Remove an existing object",id:"remove-an-existing-object",level:3},{value:"Move an agent to another location",id:"move-an-agent-to-another-location",level:3},{value:"Explore other agents and resources",id:"explore-other-agents-and-resources",level:2},{value:"Importing data for a Grid Environment",id:"importing-data-for-a-grid-environment",level:2},{value:"Exporting data for a Grid Environment",id:"exporting-data-for-a-grid-environment",level:2},{value:"Special Cases",id:"special-cases",level:2},{value:"How to Calculate a Bearing",id:"how-to-calculate-a-bearing",level:3}],d={toc:p};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"spatialhashenvironment-grid-environment"},"SpatialHashEnvironment (Grid Environment)"),(0,i.kt)("p",null,"A grid is an environment in which the world is divided into cells of equal size, like on a chessboard. An object (an agent or an entity) on the grid can be moved along the horizontal, vertical, and diagonal axes. A simple example showing a few functionalities can be found ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/tree/master/C%23%20Models/Grid_Test%20CS"},"here"),"."),(0,i.kt)("h2",{id:"creating-an-environment"},"Creating an environment"),(0,i.kt)("p",null,"In MARS, a grid environment is represented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"SpatialHashEnvironment")," with two dimensions, corresponding to the x-axis and y-axis of a Cartesian coordinate system. To initialize a grid environment, the size of each dimension needs to be specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnvironment<Sheep> Environment = new SpatialHashEnvironment<Sheep>(10, 10);\n")),(0,i.kt)("p",null,"In this example, the initialized ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," consists of 10 x 10 individual cells. The grid is defined by a so-called bounding box with lower-left bound (0,0) and upper-right bound (9,9). The ",(0,i.kt)("inlineCode",{parentName:"p"},"Sheep")," agents live on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," can be defined to move on it as described below."),(0,i.kt)("p",null,"Optionally, a ",(0,i.kt)("inlineCode",{parentName:"p"},"cellSize")," can be specified to change the size of an individual grid cell (default is 1)."),(0,i.kt)("h2",{id:"interaction-withwithin-the-grid-environment"},"Interaction with/within the Grid Environment"),(0,i.kt)("h3",{id:"add-an-agent-to-the-environment"},"Add an agent to the environment"),(0,i.kt)("p",null,"To add an object (for example, an agent or entity) to the grid, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert()")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"environment")," is used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Position = RandomPosition();\nEnvironment.Insert(this);\n")),(0,i.kt)("p",null,"This example takes place in the initialization method of an agent ",(0,i.kt)("inlineCode",{parentName:"p"},"Sheep"),". The agent has a property ",(0,i.kt)("inlineCode",{parentName:"p"},"Position"),". This property is initialized with a random position that consists of a tuple (x,y). Once the agent has a defined position, it can be placed on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," by calling the environment's ",(0,i.kt)("inlineCode",{parentName:"p"},"Insert(<object reference>)")," method and passing a reference to the agent."),(0,i.kt)("h3",{id:"remove-an-existing-object"},"Remove an existing object"),(0,i.kt)("p",null,"Removing an agent follows the same principle as adding it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Remove(<object to remove>)")," method is executed via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," and the entity to be removed is specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.Remove(<object to remove>);\n")),(0,i.kt)("h3",{id:"move-an-agent-to-another-location"},"Move an agent to another location"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"SpatialHashEnvironment")," (i.e., the grid environment) enables agents to move on it. There are three movement methods, which are illustrated in the following examples."),(0,i.kt)("p",null,"The first movement method is ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTo()"),", which is called as shown below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTo(this, <position tuple (x, y)>);\n")),(0,i.kt)("p",null,"Upon execution of the above code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," determines the shortest path between the agent's current position and the goal position specified in the method's second parameter."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," There are different options for the second parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTo()"),". Alternatively to the tuple shown above, the method can take two individual double values ","\u2013"," representing the x- and y-coordinate of the desired position, respectively ","\u2013"," as the second and third parameter. Or an array of double values can be passed to represent a path which the agent should travel along."),(0,i.kt)("p",null,"The second movement method is ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveTowards()"),". This method can be called either with a ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectionType")," enum or with a bearing double."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTowards(this, <DirectionType>);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Environment.MoveTowards(this, <bearing>);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectionType")," enum can be ",(0,i.kt)("inlineCode",{parentName:"p"},"Up"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Down"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpRight"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpLeft"),", etc. The bearing can be a double between 0.0 (equivalent to the direction type ",(0,i.kt)("inlineCode",{parentName:"p"},"Up"),") and 360.0 and specifies the angle to which the agent should turn and move. For more information on how to calculate a bearing, please see ",(0,i.kt)("a",{parentName:"p",href:"#how-to-calculate-a-bearing"},"here"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"SpatialHashEnvironment")," provides the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CheckBoundaries"),": Checking for specified boundaries and reposition entities that move out the dimensions."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DistanceFunction"),": The distance function used for ",(0,i.kt)("inlineCode",{parentName:"li"},"Explore")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Move")," actions, interpreting the passed exploration radius or moving distance (default is ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Chebyshev_distance"},"Chebyshev"),")")),(0,i.kt)("h2",{id:"explore-other-agents-and-resources"},"Explore other agents and resources"),(0,i.kt)("p",null,"Agents can explore an environment to identify other agents and resources by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore()")," method on the environment. Below is an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Sheep> result = Environment.Explore();\n")),(0,i.kt)("p",null,"This call explores the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Sheep")," agents. Since no parameters are specified, the entire ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," is explored. ",(0,i.kt)("strong",{parentName:"p"},"Note: in simulations with many agents, this can be computationally costly.")),(0,i.kt)("p",null,"Alternatively, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore()")," method can also be called with parameters. The signature is ",(0,i.kt)("inlineCode",{parentName:"p"},"Explore(<position>, <search_radius>, <number_of_objects>, <filter_predicate>)"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"position")," is the position (consisting of an ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," coordinate) from which the exploration should begin (e.g., the caller's current position)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<search_radius>")," is the extent of the exploration (e.g., an ",(0,i.kt)("inlineCode",{parentName:"li"},"Explore()")," call with a search radius of ",(0,i.kt)("inlineCode",{parentName:"li"},"5")," on a grid environment explores the environment within five grid cells of the specified ",(0,i.kt)("inlineCode",{parentName:"li"},"<position>"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<number_of_objects>")," is the maximum number of objects (i.e., ",(0,i.kt)("inlineCode",{parentName:"li"},"Sheep")," agents, in case of the current example) that should be returned as a result of the exploration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<filter_predicate>")," is an optional predicate (selection expression) that can be applied to the exploration goal (in this case ",(0,i.kt)("inlineCode",{parentName:"li"},"Sheep")," agents) in case only those agents that satisfy a certain condition are required. Below is an example of a full ",(0,i.kt)("inlineCode",{parentName:"li"},"Explore()")," call.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Sheep> result = Environment.Explore(Position, 20, -1, agentInEnvironment => agentInEnvironment.Energy > 50);\n")),(0,i.kt)("p",null,"In this example, all ",(0,i.kt)("inlineCode",{parentName:"p"},"Sheep")," agents within ",(0,i.kt)("inlineCode",{parentName:"p"},"20")," steps that satisfy the ",(0,i.kt)("inlineCode",{parentName:"p"},"Energy > 50")," condition are returned and stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable")," collection. By specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," in the second parameter, the results are not limited by search radius."),(0,i.kt)("p",null,"Furthermore, if you want to query the entire spatial space, you specify ",(0,i.kt)("inlineCode",{parentName:"p"},"-1D")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"<radius>"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable<Sheep> result = Environment.Explore(Position, -1D, -1, agentInEnvironment => agentInEnvironment.Energy > 50);\n")),(0,i.kt)("p",null,"In this case, all registered ",(0,i.kt)("inlineCode",{parentName:"p"},"Sheep")," agents in the environment are queried for the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"Energy > 50"),". However, the filter specified in the fourth parameter is still applied to potentially filter the results based on whether the agents satisfy the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"Energy > 50"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Alternatively, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Select()")," and other LINQ queries can be formulated on the ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<Sheep> result"),", which will be evaluated after the query is executed."),(0,i.kt)("h2",{id:"importing-data-for-a-grid-environment"},"Importing data for a Grid Environment"),(0,i.kt)("p",null,"Initial data for a ",(0,i.kt)("inlineCode",{parentName:"p"},"SpatialHashEnvironment")," can be imported by specifying a file in the model's configuration file ",(0,i.kt)("em",{parentName:"p"},"config.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'Previous section...\n"layers": [  \n  {  \n    "name":"MyGridLayer",  \n    "file": "Resources/grid.csv"\n  }\n]\nNext section...\n')),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"layers"),", the grid environment ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGridLayer")," receives initial information to be inserted into its grid cells via with initialization file ",(0,i.kt)("inlineCode",{parentName:"p"},"grid.csv"),". For example, in the wolf-sheep-grass model, this information can represent the initial amount of grass per grid cell (e.g., as an integer or double). For an example of an initialization file for a grid environment, please click ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/blob/master/C%23%20Models/Grid_Test%20CS/Grid_Test%20CS/Resources/grid.csv"},"here"),"."),(0,i.kt)("p",null,"Within the ",(0,i.kt)("inlineCode",{parentName:"p"},"InitLayer(...)")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGridLayer")," class, the data can be loaded as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"GridEnvironment = new SpatialHashEnvironment<Sheep>(Height, Width);\n")),(0,i.kt)("p",null,"If the class name matches the name of the layer in config.json (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGridLayer")," in the above example), then the MARS runtime system obtains values for properties such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Height")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Width")," from the referenced CSV file and integrate the data from the file into the environment."),(0,i.kt)("p",null,"The above code snippet can be used to integrate input data from a file (e.g., a CSV file) into the environment. For more information and an example, please see ",(0,i.kt)("a",{parentName:"p",href:"https://git.haw-hamburg.de/mars/model-deployments/-/blob/master/C%23%20Models/Grid_Test%20CS/Grid_Test%20CS/Model/MyGridLayer.cs"},"here"),"."),(0,i.kt)("h2",{id:"exporting-data-for-a-grid-environment"},"Exporting data for a Grid Environment"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"SpatialHashEnvironment")," can be exported to a number of output formats. In the below example, CSV and JSON are illustrated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'File.WriteAllText("gridEnvironment.csv", environment.ToCsv());\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'File.WriteAllText("gridEnvironment.json", environment.ToJson());\n')),(0,i.kt)("h2",{id:"special-cases"},"Special Cases"),(0,i.kt)("h3",{id:"how-to-calculate-a-bearing"},"How to Calculate a Bearing"),(0,i.kt)("p",null,"The Cartesian bearing (in degrees) between two Cartesian coordinates is the angle between them relative to the ",(0,i.kt)("inlineCode",{parentName:"p"},"UP")," position. The ",(0,i.kt)("inlineCode",{parentName:"p"},"UP")," position points north and its bearing is equal to 0.0. From there, the size the angle increases in the clockwise direction."),(0,i.kt)("p",null,"The following two methods can be used to calculate a bearing between two positions. The first method takes the two positions directly, whereas the second method takes the individual coordinates of each position (as doubles)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var bearing = GetBearingCartesian(<start_position>, <goal_position>)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var bearing = CalculateBearingCartesian(<start_x>, <start_y>, <goal_x>, <goal_y>)\n")))}m.isMDXComponent=!0}}]);